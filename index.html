<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>PokeSackTotal Choropleth Map</title>
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
        integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous" />
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
        integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,800;1,800&display=swap"
        rel="stylesheet" />
</head>
<style>
    body {
        background: #20282e;
        font-family: "Open Sans", sans-serif;
        font-weight: 400;
        font-size: 100%;
    }

    #map {
        /* height is set in JS */
        background: #2d2f31;
    }
</style>

<body>
    <div class="container-fluid">
        <header class="row bg-dark text-white p-2">
            <div class="col-8">
                <h1>Total Amount of Bags, Sacks, And Pokes</h1>
                <h2>per states</h2>
            </div>
            <div class="col-4 align-self-center">
                <p class="d-flex justify-content-end my-auto">This will be a choropleth map of the amount of totals of
                    sacks, totals, and bags in certain states.</p>
            </div>
        </header>
        <section class="row">
            <div class="p-0">
                <div id="map"></div>
            </div>
        </section>
</body>
<!-- Add Bootstrap -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4"
    crossorigin="anonymous"></script>
<!-- then Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"
    integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
<!-- then Simple Statistics -->
<script src="https://unpkg.com/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>
<script>
    // set global variables for map layer,
    // mapped attribute
    let attributeValue = "RENT";

    // Add footer date
    setDate()

    // set global variables for header, map container, and footer
    const header = document.querySelector("header");
    const mapContainer = document.querySelector("#map");
    const footer = document.querySelector("footer");

    // set map height to fill window
    mapContainer.style.height =
        window.innerHeight - header.offsetHeight - footer.offsetHeight + "px";

    // initial Leaflet map options
    const options = {
        center: [37.8, -85.8],
        zoom: 5,
        zoomSnap: 0.5,
        zoomControl: false,
        attributionControl: false,
    };

    // create Leaflet map and apply options
    const map = L.map("map", options);

    // fetch data
    fetch("geojson/BagTotal.geojson")
        .then(function (response) {
            return response.json();
        })
        .then(function (data) {
            // This is the JSON from our response
            // Draw basic map from data
            var dataLayer = L.geoJson(data, {
                style: function (feature) {
                    return {
                        color: "#333",
                        weight: 1,
                        fillOpacity: 1,
                        fillColor: "#1f78b4",
                    };
                },
            }).addTo(map);
            // Make call to update map
            console.log(dataLayer)
            drawMap(dataLayer);
            // if (response.ok) {
            //   return response.json();
            // } else {
            //   throw new Error(`HTTP error! status: ${response.status}`);
            // }
            // Return a new fetch call and continue the chain
            return fetch("data/us_states_20m.geojson")
        })
        .then(function (response) {
            return response.json()
        })
        .then(function (data) {
            console.log(data);
            drawAnotherLayer(data)
        })
        // If there is an error, log it to the console
        .catch(function (error) {
            console.log(error);
        });

    // Example of keeping your page fresh
    function setDate() {
        const date = new Date();
        const year = date.getFullYear();
        const month = date.toLocaleString('default', { month: 'long' });
        const footerText = document.querySelector("footer p");
        footerText.innerHTML = `${month}, ${year} | New Maps Plus`;
    }

    // start DrawMap(dataLayer)

    function drawMap(dataLayer) {
        var breaks = getClassBreaks(dataLayer);

        dataLayer.eachLayer(function (layer) {
            console.log(layer.feature.properties);
        });

        dataLayer.eachLayer(function (layer) {
            var props = layer.feature.properties;

            layer.setStyle({
                fillColor: getColor(
                    props[attributeValue], breaks
                ),
            });

            var toolTipInfo = `<h3>${props.NAME} County</h3>`

            if (props[attributeValue] < 0) {
                toolTipInfo += `<p>No data</p>`;
            } else {
                toolTipInfo += `<p>$${props[attributeValue]}</p>`;
            }

            layer.bindTooltip(toolTipInfo, {
                sticky: true,
                className: "leaflet-tooltip-own",
            });
        });

        drawLegend(breaks);
    } // end drawMap()

    // start GetClassBreaks(dataLayer) function
    function getClassBreaks(dataLayer) {
        // create empty Array for storing values
        const values = [];

        // loop through all the counties
        dataLayer.eachLayer(function (layer) {
            var props = layer.feature.properties;
            var value = props[attributeValue];

            if (value >= 0) {
                values.push(value);
            }
        });

        // determine similar clusters
        var clusters = ss.ckmeans(values, 5);

        // create an array of the lowest value within each cluster
        var breaks = clusters.map(function (cluster) {
            return [cluster[0], cluster.pop()];
        });

        return breaks; // return Array of class breaks
    }
    // end getClassBreaks function

    // start drawAnotherLayer(data)
    function drawAnotherLayer(data) {
        L.geoJson(data, {
            style: function (feature) {
                return {
                    color: "#222",
                    // Make line weight larger than the county outline
                    weight: 2,
                    fillOpacity: 0,
                    // This property allows us control interactivity of layer
                    interactive: false,
                };
            },
        }).addTo(map);
    }
    // end drawAnotherLayer(data)

    // start getColor
    function getColor(d, breaks) {
        if (d <= 0) {
            return "grey";
        } else if (d <= breaks[0][1]) {
            return "#f7fbff";
        } else if (d <= breaks[1][1]) {
            return "#c8dcf0";
        } else if (d <= breaks[2][1]) {
            return "#73b2d8";
        } else if (d <= breaks[3][1]) {
            return "#2979b9";
        } else if (d <= breaks[4][1]) {
            return "#08306b";
        }
    }
    // end getColor

    // start drawLegend
    function drawLegend(breaks) {
        // create a new Leaflet control object, and position it top left
        const legend = L.control({ position: "topleft" });

        // when the legend is added to the map
        legend.onAdd = function () {
            // create a new HTML <div> element and give it a class list
            const div = L.DomUtil.create('div',
                'legend d-flex flex-column px-3 py-2');

            // first append an <h3> tag to the div holding the current attribute
            // and norm values (i.e., the mapped phenomena)
            div.innerHTML = `<h3>${attributeValue}</h3>`;

            // for each of our breaks
            for (let i = 0; i < breaks.length; i++) {
                // determine the color associated with each break value,
                // including the lower range value
                const color = getColor(breaks[i][0], breaks);

                // concatenate a <span> tag styled with the color and the range values
                // of that class and include a label with the low and a high ends of that class range
                div.innerHTML +=
                    `<div class="d-flex flex-row justify-content-start">
                <span style="background:${color}"></span>
                <label>$${(breaks[i][0])} &mdash; 
                $${(breaks[i][1])}</label>
            </div>`;
            }

            div.innerHTML +=
                `<div class="d-flex flex-row justify-content-start">
                <span style="background:grey"></span>
                <label>No data</label>
            </div>`;

            // return the populated div to be added to the map
            return div;
        };

        // add the legend to the map
        legend.addTo(map);
    }

    map.addControl(L.control.zoom({ position: "topright" }));
</script>